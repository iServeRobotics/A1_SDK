<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>pinocchio: Dealing with Lie group geometry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pinocchio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pinocchio
   &#160;<span id="projectnumber">2.5.1</span>
   </div>
   <div id="projectbrief">A fast and flexible implementation of Rigid Body Dynamics algorithms and their analytical derivatives</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_a-features_e-lie.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dealing with Lie group geometry </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Pinocchio relies heavily on Lie groups and Lie algebras to handle motions and more specifically rotations. For this reason it supports the following special groups \( SO(2), SO(3), SE(2), SE(3) \) and implements their associated algebras \( \mathfrak{se}(2) , \mathfrak{se}(3) \). It has various applications like representing the motion of a robot free flyer joint (typically the base of a mobile robot), or the motion of the robot links. The later is particularly useful for collision detection. It is also interesting to have general vector space over which a Lie algebra is defined.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Using \( SE(2) \) with pinocchio in C++</h1>
<p>As a motivating example let us consider a mobile robot evolving in a plane \((\mathbb{R}^2 \times \mathbb{S}^1 \)). </p><div class="image">
<object type="image/svg+xml" data="SE2MotivatingExample.svg" style="pointer-events: none;"></object>
<div class="caption">
SE2MotivatingExample</div></div>
   <p>The robot starts at position \( pose_s = (x_s,y_s,\theta_s) \) and after a rigid motion \( \delta_u=(\delta x,\delta y,\delta \theta) \) it finishes at \( pose_g = (x_{g},y_{g},\theta_{g})\). It is possible to instantiate the corresponding \(SE(2)\) objects using:</p>
<div class="fragment"><div class="line">typedef double Scalar;</div>
<div class="line">enum {Options = 0};</div>
<div class="line"> </div>
<div class="line">SpecialEuclideanOperationTpl&lt;2,Scalar,Options&gt; aSE2;</div>
<div class="line">SpecialEuclideanOperationTpl&lt;2,Scalar,Options&gt;::ConfigVector_t pose_s,pose_g;</div>
<div class="line">SpecialEuclideanOperationTpl&lt;2,Scalar,Options&gt;::TangentVector_t delta_u;</div>
</div><!-- fragment --><p> You can change Scalar by another type such as float.</p>
<p>In this example, \( pose_s=(1,1,\pi/4)\) and \( pose_g=(3,1,-\pi/2) \) and we want to compute \( \delta_u \) </p><div class="fragment"><div class="line">pose_s(0) = 1.0; pose_s(1) = 1.0;</div>
<div class="line">pose_s(2) = cos(M_PI/4.0); pose_s(3) = sin(M_PI/4.0);</div>
<div class="line">pose_g(0) = 3.0; pose_g(1) = -1.0;</div>
<div class="line">pose_g(2) = cos(-M_PI/2.0); pose_g(3) = sin(-M_PI/2.0);</div>
<div class="line"> </div>
<div class="line">aSE2.difference(pose_s,pose_g,delta_u);</div>
<div class="line">std::cout &lt;&lt; delta_u &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>aSE2 is used to compute the difference between two configuration vectors representing the two poses. Note that the rotation is represented by two numbers \( sin(\theta),cos(\theta)\) which is also a \( SO(2) \) object. The difference lies in the tangent space of \( SE(2)\) and is representend by a vector of 3 reals. Therefore the output is:</p>
<div class="fragment"><div class="line"> 3.33216</div>
<div class="line">-1.38023</div>
<div class="line">-2.35619</div>
</div><!-- fragment --><p>Note that the linear part is not following a straight path, it also takes into account that the system is rotating.</p>
<p>We can verify that this is the appropriate motion by integrating: </p><div class="fragment"><div class="line">SpecialEuclideanOperationTpl&lt;2,Scalar,Options&gt;::ConfigVector_t pose_check;</div>
<div class="line"> </div>
<div class="line">aSE2.integrate(pose_s,delta_u,pose_check);</div>
<div class="line">std::cout &lt;&lt; pose_check &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The result is indeed:</p>
<div class="fragment"><div class="line">3</div>
<div class="line">-1</div>
<div class="line"> 0</div>
<div class="line">-1</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Using \f$ SE(3) \f$ with pinocchio in C++</h1>
<p>Our mobile robot is not in a plane but in a 3-dimensional space. So let's consider a object in our physical space. This is actually almost the same case, we want the object from one position to an other position. The difficulty lies in the fact that we now have three dimensions so the object has six degrees of freedom, three corresponding to its translation and three to its rotation.</p>
<div class="image">
<img src="SE3Example1.jpg" alt=""/>
<div class="caption">
SE3MotivatingExample</div></div>
   <p>It is also possible to instantiate the corresponding object which is now a \( SE(3) \) object using the same algorithm and changing the dimension parameter:</p>
<div class="fragment"><div class="line">typedef double Scalar;</div>
<div class="line">enum {Options = 0};</div>
<div class="line"> </div>
<div class="line">SpecialEuclideanOperationTpl&lt;3,Scalar,Options&gt; aSE3 ;</div>
<div class="line">SpecialEuclideanOperationTpl&lt;3,Scalar,Options&gt;::ConfigVector_t pose_s,pose_g;</div>
<div class="line">SpecialEuclideanOperationTpl&lt;3,Scalar,Options&gt;::TangentVector_t delta_u ;</div>
</div><!-- fragment --><p>In this example, \( pose_s=(1,1,1,\pi/2,\pi/4,\pi/8)\) and \( pose_g=(4,3,3,\pi/4,\pi/3, -\pi) \). For the starting position, there is first a rotation around the y-axis then the x-axis and finally the z-axis. For the final position, the rotations are in this order, x-axis, y-axis, z-axis. We want to compute \( \delta_u \).</p>
<ul>
<li><p class="startli">For the first pose, we have the three rotations matrices for each rotation :</p>
<p class="startli">\( R_{x_s} = \begin{bmatrix} 1 &amp;0 &amp;0 \\ 0 &amp;cos(\pi/8) &amp;-sin(\pi/8) \\0 &amp;sin(\pi/8) &amp;cos(\pi/8) \end{bmatrix} \ \ R_{y_s} = \begin{bmatrix} cos(\pi/4) &amp;0 &amp;sin(\pi/4) \\ 0 &amp;1 &amp;0 \\-sin(\pi/4) &amp;0 &amp;cos(\pi/4) \end{bmatrix} \ \ R_{z_s} = \begin{bmatrix} cos(\pi/2) &amp;-sin(\pi/2) &amp;0 \\sin(\pi/2) &amp;cos(\pi/2) &amp;0 \\ 0 &amp;0 &amp;1\end{bmatrix} \)</p>
<p class="startli">Therefore, the complete rotation is:</p>
<p class="startli">\( R_{pose_s} = R_{s_z} * R_{s_x} * R_{s_y} = \begin{bmatrix} 0 &amp;-1 &amp;0 \\ cos(\pi/4)*cos(\pi/8) + sin(\pi/4) * sin(\pi/8) &amp;0 &amp;sin(\pi/4) * cos(\pi/8) - cos(\pi/4) * sin(\pi/8) \\ sin(\pi/8) * cos(\pi/4) - cos(\pi/8) * sin(\pi/4) &amp;0 &amp;sin(\pi/4) * sin(\pi/8) + cos(\pi/4) * cos(\pi/8) \end{bmatrix} \)</p>
</li>
<li><p class="startli">For the second one, we have:</p>
<p class="startli">\( R_{x_g} = \begin{bmatrix} 1 &amp;0 &amp;0 \\ 0 &amp;cos(\pi/4) &amp;-sin(\pi/4) \\0 &amp;sin(\pi/4) &amp;cos(\pi/4) \end{bmatrix} \ \ R_{y_g} = \begin{bmatrix} cos(\pi/3) &amp;0 &amp;sin(\pi/3) \\ 0 &amp;1 &amp;0 \\ -sin(\pi/3) &amp;0 &amp;cos(\pi/3) \end{bmatrix} \ \ R_{z_g} = \begin{bmatrix} cos(-\pi) &amp;-sin(-\pi) &amp;0 \\ sin(-\pi) &amp;cos(-\pi) &amp;0 \\ 0 &amp;0 &amp;1\end{bmatrix} \)</p>
<p class="startli">The complete rotation is:</p>
<p class="startli">\( R_{pose_g} = \begin{bmatrix} -cos(\pi/3) &amp;-sin(\pi/3) * sin(\pi/4) &amp;-cos(\pi/4) * sin(\pi/3) \\ 0 &amp;-cos(\pi/4) &amp;sin(\pi/4) \\ -sin(\pi/3) &amp;sin(\pi/4) * cos(\pi/3) &amp;cos(\pi/3) * cos(\pi/4) \end{bmatrix} \)</p>
</li>
</ul>
<p>To compute \( \delta_u \) using Pinocchio we need to transform \( R_{pose_s} \) and \( R_{pose_g} \) matrices into quaternions using:</p>
<div class="fragment"><div class="line">float s = 0.5f / sqrtf(trace+ 1.0f);</div>
<div class="line">q.x = ( R[2][1] - R[1][2] ) * s;</div>
<div class="line">q.y = ( R[0][2] - R[2][0] ) * s;</div>
<div class="line">q.z = ( R[1][0] - R[0][1] ) * s;</div>
<div class="line">q.w = 0.25f / s;</div>
</div><!-- fragment --><p>The quaternions components are:</p><ul>
<li>For the first rotation <div class="fragment"><div class="line">0.69352</div>
<div class="line">-0.13795</div>
<div class="line">0.13795</div>
<div class="line">0.69352</div>
</div><!-- fragment --></li>
<li>For the second one <div class="fragment"><div class="line">0.191342</div>
<div class="line">-0.46194</div>
<div class="line">0.331414</div>
<div class="line">0.800103</div>
</div><!-- fragment --></li>
</ul>
<p>For each pose we have now a mathematical object with seven components and both are normalized. As for the \( SE(2) \) example we compute \( \delta_u \) using:</p>
<div class="fragment"><div class="line">pose_s(0) = 1.0; pose_s(1) = 1.0;</div>
<div class="line">pose_s(2) = 1 ; pose_s(3) = -0.13795 ; </div>
<div class="line">pose_s(4) = 0.13795; pose_s(5) = 0.69352; pose_s(6) = 0.69352;</div>
<div class="line">pose_g(0) = 4; pose_g(1) = 3 ;</div>
<div class="line">pose_g(2) = 3 ; pose_g(3) = -0.46194;</div>
<div class="line">pose_g(4) = 0.331414; pose_g(5) = 0.800103; pose_g(6) = 0.191342; </div>
<div class="line"> </div>
<div class="line">aSE3.difference(pose_s,pose_g,delta_u);</div>
<div class="line">std::cout &lt;&lt; delta_u &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The difference lies in the tangent space of \( SE(3)\) and is represented by a vector of 6 reals which is:</p>
<div class="fragment"><div class="line">-1.50984</div>
<div class="line">-3.58755</div>
<div class="line">2.09496</div>
<div class="line">-0.374715</div>
<div class="line">0.887794</div>
<div class="line">0.86792</div>
</div><!-- fragment --><p>The three first values are linear and the three last are velocities.</p>
<p>To verify it is the good solution, we integrate:</p>
<div class="fragment"><div class="line">SpecialEuclideanOperationTpl&lt;3,Scalar,Options&gt;::ConfigVector_t pose_check;</div>
<div class="line"> </div>
<div class="line">aSE3.integrate(pose_s,delta_u,pose_check);</div>
<div class="line">std::cout &lt;&lt; pose_check &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Indeed, we find :</p>
<div class="fragment"><div class="line">4</div>
<div class="line">3</div>
<div class="line">3</div>
<div class="line">-0.46194</div>
<div class="line">0.331414</div>
<div class="line">0.800103</div>
<div class="line">0.191234</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Using interpolation to plot a trajectory with pinocchio in C++</h1>
<p>Assuming that we want to make the robot pass through known positions, we can use interpolations to plot a trajectory.</p>
<p>The problem is an interpolation such as Lagrange's one only takes into account translations whlie the robot interact with its environment by performing translations and rotations.</p>
<p>A possibility is to use the \( \delta_{theta} \) method by using quaternions. The method is simple, we just vary the angle, the scalar component of the quaternion, with very small variations.</p>
<p>Let's consider the previous example, we can interpolate trajectory using: </p><div class="fragment"><div class="line">SpecialEuclideanOperationTpl&lt;3,Scalar,Options&gt;::ConfigVector_t pole;</div>
<div class="line">aSE3.interpolate(pose_s,pose_g,0.5f, pole);</div>
<div class="line">std::cout &lt;&lt; pole &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The output corresponds to the middle of the trajectory and is: </p><div class="fragment"><div class="line">2.7486</div>
<div class="line">1.4025</div>
<div class="line">2.22461</div>
<div class="line">-0.316431</div>
<div class="line">0.247581</div>
<div class="line">0.787859</div>
<div class="line">0.466748</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
