<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>pinocchio: 2) Grasp an object (aka inverse Geometry)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pinocchio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pinocchio
   &#160;<span id="projectnumber">2.5.1</span>
   </div>
   <div id="projectbrief">A fast and flexible implementation of Rigid Body Dynamics algorithms and their analytical derivatives</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_d-practical-exercises_2-invgeom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">2) Grasp an object (aka inverse Geometry) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md156"></a>
Objectives</h1>
<p>The main objective of the first tutorial is to compute a configuration of the robot minimizing a cost (maximizing a reward) and respecting some given constraints. Additionally, the objective is to have a first hands on the difficulties of working outside of real vector spaces and to consider what are the guesses that are taken by an optimal solver.</p>
<h1><a class="anchor" id="autotoc_md157"></a>
2.0) Technical prerequisites</h1>
<h2><a class="anchor" id="autotoc_md158"></a>
Python SciPy and MatplotLib</h2>
<p>You will need the two Python libraries: <em>SciPy</em> (scientific Python) and <em>MatPlotLib</em> (plot mathematical data).</p>
<p>SciPy can be installed by <code>sudo apt-get install python-scipy</code>. Examples of calls of these two functions are given below. We will use both solvers with numerical (finite-differencing) differentiation, to avoid the extra work of differencing the cost and constraint functions by hand. In general, it is strongly advice to first test a numerical program with finite differencing, before implementing the true derivatives only if needed. In any case, the true derivatives must always be checked by comparing the results with the finite differentiation.</p>
<p>Additionally, the provided implementation of BFGS allows the user to provide a callback function and track the path taken by the solver, but does not provide the possibility to specify constraints (constraints can be added as penalty functions in the cost, but this requires additional work). The constrained least-square implementation allows the user to specify equality and inequality constraints, but not the callback. In the following, start to use BFGS before moving to the constrained least-square only when constraints are really needed.</p>
<div class="fragment"><div class="line"><span class="comment"># Example of use a the optimization toolbox of SciPy.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">from</span> <a class="code" href="namespacescipy_1_1optimize.html">scipy.optimize</a> <span class="keyword">import</span> fmin_bfgs, fmin_slsqp</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>cost(x):</div>
<div class="line">    <span class="stringliteral">&#39;&#39;&#39;Cost f(x, y) = x² + 2y² - 2xy - 2x &#39;&#39;&#39;</span></div>
<div class="line">    x0, x1 = x</div>
<div class="line">    <span class="keywordflow">return</span> -(2 * x0 * x1 + 2 * x0 - x0 ** 2 - 2 * x1 ** 2)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>constraint_eq(x):</div>
<div class="line">    <span class="stringliteral">&#39;&#39;&#39; Constraint x³ = y &#39;&#39;&#39;</span></div>
<div class="line">    <span class="keywordflow">return</span> np.array([ x[0] ** 3 - x[1] ])</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>constraint_ineq(x):</div>
<div class="line">   <span class="stringliteral">&#39;&#39;&#39;Constraint x &gt;= 2, y &gt;= 2&#39;&#39;&#39;</span></div>
<div class="line">   <span class="keywordflow">return</span> np.array([ x[0] - 2, x[1] - 2 ])</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CallbackLogger:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self.nfeval = 1</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__call__(self,x):</div>
<div class="line">        print(<span class="stringliteral">&#39;===CBK=== {0:4d} {1: 3.6f} {2: 3.6f} {3: 3.6f}&#39;</span>.format(self.nfeval, x[0], x[1], cost(x)))</div>
<div class="line">        self.nfeval += 1</div>
<div class="line"> </div>
<div class="line">x0 = np.array([0.0, 0.0])  <span class="comment"># Optimize cost without any constraints in BFGS, with traces.</span></div>
<div class="line">xopt_bfgs = fmin_bfgs(cost, x0, callback=CallbackLogger())</div>
<div class="line">print(<span class="stringliteral">&#39;*** Xopt in BFGS =&#39;</span>, xopt_bfgs)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Optimize cost without any constraints in CLSQ</span></div>
<div class="line"> </div>
<div class="line">xopt_lsq = fmin_slsqp(cost, [-1.0, 1.0], iprint=2, full_output=1)</div>
<div class="line">print(<span class="stringliteral">&#39;*** Xopt in LSQ =&#39;</span>, xopt_lsq)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Optimize cost with equality and inequality constraints in CLSQ</span></div>
<div class="line"> </div>
<div class="line">xopt_clsq = fmin_slsqp(cost, [-1.0, 1.0], f_eqcons=constraint_eq, f_ieqcons=constraint_ineq, iprint=2, full_output=1)</div>
<div class="line">print(<span class="stringliteral">&#39;*** Xopt in c-lsq =&#39;</span>, xopt_clsq)</div>
</div><!-- fragment --><p>Take care that all <em>SciPy</em> always works with vectors represented as 1-dimensional array, while Pinocchio works with vectors represented as matrices (which are in fact two-dimensional arrays, with the second dimension being 1). You can pass from a SciPy-like vector to a Pinocchio-like vector using:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line">x = np.array([1.0, 2.0, 3.0])</div>
<div class="line">q = np.matrix(x).T</div>
<div class="line">x = q.getA()[:, 0]</div>
</div><!-- fragment --><p>The second library <em>MatPlotLib</em> plots values on a 2D graph. A tutorial is available <a href="https://www.labri.fr/perso/nrougier/teaching/matplotlib/">here</a>. An example is provided below.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="comment"># In plt, the following functions are the most useful:</span></div>
<div class="line"><span class="comment"># ion, plot, draw, show, subplot, figure, title, savefig</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># For use in interactive python mode (ipthyon -i)</span></div>
<div class="line">interactivePlot = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> interactivePlot:</div>
<div class="line">    plt.ion()  <span class="comment"># Plot functions now instantaneously display, shell is not blocked</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Build numpy array for x axis</span></div>
<div class="line">x = 1e-3 * np.array(range(100))</div>
<div class="line"><span class="comment"># Build numpy array for y axis</span></div>
<div class="line">y = x ** 2</div>
<div class="line"> </div>
<div class="line">fig = plt.figure()</div>
<div class="line">ax = fig.add_subplot(<span class="stringliteral">&#39;111&#39;</span>)</div>
<div class="line">ax.plot(x, y)</div>
<div class="line">ax.legend((<span class="stringliteral">&quot;x^2&quot;</span>, ))</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> interactivePlot:</div>
<div class="line">    <span class="comment"># Display all the plots and block the shell.</span></div>
<div class="line">    <span class="comment"># The script will only ends when all windows are closed.</span></div>
<div class="line">    plt.show()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md159"></a>
Robots</h2>
<p>We mostly use here the model UR5, used in the first lab. Refer to the instructions of Lab 1 to load it.</p>
<p>Optionally, we might want to use a more complex robot model. Romeo is a humanoid robot developed by the French-Japanese company Aldebaran Robotics. It has two legs, two arms and a head, for a total of 31 joints (plus 6DOF on the free flyer). The description of Romeo can be obtained with:</p>
<div class="fragment"><div class="line">sudo apt install robotpkg-romeo-description</div>
</div><!-- fragment --><p>Romeo can be loaded with:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join</div>
<div class="line"><span class="keyword">import</span> pinocchio <span class="keyword">as</span> se3</div>
<div class="line"><span class="keyword">from</span> pinocchio.romeo_wrapper <span class="keyword">import</span> RomeoWrapper</div>
<div class="line"> </div>
<div class="line">PKG = <span class="stringliteral">&#39;/opt/openrobots/share&#39;</span></div>
<div class="line">URDF = join(PKG, <span class="stringliteral">&#39;romeo_description/urdf/romeo.urdf&#39;</span>)</div>
<div class="line"> </div>
<div class="line">robot = RomeoWrapper(URDF, [PKG])  <span class="comment"># Load urdf model</span></div>
<div class="line">robot.initDisplay(loadModel=<span class="keyword">True</span>)</div>
</div><!-- fragment --><p>Additionally, the index of right and left hands and feet are stored in <code>robot.rh</code>, <code>robot.lh</code>, <code>robot.rf</code> and <code>robot.lf</code>.</p>
<h1><a class="anchor" id="autotoc_md160"></a>
2.1) Position the end effector</h1>
<p>The first tutorial is to position (i.e. translation only) the end effector of a manipulator robot to a given position. For this first part, we will use the fixed serial-chain robot model.</p>
<p>Recall first that the position (3D) of the joint with index <code>i</code> at position <code>q</code> can be access by the following two lines of code:</p>
<div class="fragment"><div class="line"><span class="comment"># Compute all joint placements and put the position of joint &quot;i&quot; in variable &quot;p&quot;.</span></div>
<div class="line"><span class="keyword">import</span> pinocchio <span class="keyword">as</span> se3</div>
<div class="line">se3.forwardKinematics(robot.model, robot.data, q)</div>
<div class="line">p = robot.data.oMi[i].translation</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md161"></a>
Question 1</h3>
<p>Using this, build a cost function to be the norm of the difference between the end-effector position <code>p</code> and a desired position <code>pdes</code>. The cost function is a function that accepts as input an 1-dimensional array and return a float.</p>
<h3><a class="anchor" id="autotoc_md162"></a>
Question 2</h3>
<p>Then use <code>fmin_bfgs</code> to find a configuration <code>q</code> with the end effector at position <code>pdes</code>.</p>
<h3><a class="anchor" id="autotoc_md163"></a>
Question 3</h3>
<p>Finally, implements a callback function that display in Gepetto-Viewer every candidate configuration tried by the solver.</p>
<h1><a class="anchor" id="autotoc_md164"></a>
2.2) Approaching the redundancy (optionnal)</h1>
<p>The manipulator arm has 6 DOF, while the cost function only constraints 3 of them (the position of the end effector). A continuum of solutions then exists. The two next questions are aiming at giving an intuition of this continuum.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
Question 4</h3>
<p>Sample several configurations respecting <code>pdes</code> by giving various initial guesses to the solver. Store this sampling of solutions in a list, then display this list in Gepetto-Viewer, each configuration begin displayed during 1 second (pause of 1 seconds can be obtained using: <code>import time; time.sleep(1))</code>.</p>
<p>A configurations in this continuum can then be selected with particular properties, like for example being the closest to a reference configuration, or using some joints more than the others, or any other criterion that you can imagine.</p>
<h3><a class="anchor" id="autotoc_md166"></a>
Question 5</h3>
<p>Sum a secondary cost term to the first positioning cost, to select the posture that maximizes the similarity (minimizes the norm of the difference) to a reference posture. The relative importance of the two cost terms can be adjusted by weighting the sum: find the weight so that the reference position is obtained with a negligible error (below millimeter) while the posture is properly taken into account.</p>
<h1><a class="anchor" id="autotoc_md167"></a>
2.3) Placing the end-effector</h1>
<p>The next step is to find a configuration of the robot so that the end effector respects a reference placement, i.e. position and orientation. The stake is to find a metric in \(SE(3)\) to continuously quantify the distance between two placements. There is no canonical metric in \(SE(3)\), i.e. no absolute way of weighting the position with respect to the orientation. Two metrics can be considered, namely the log in \(SE(3)\) or in \(R^3 \times SO(3)\). The tutorial will guide you through the first choice.</p>
<p>The \(SE(3)\) and \(SO(3)\) logarithm are implemented in Pinocchio in the <code>explog</code> module.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pinocchio.explog <span class="keyword">import</span> log</div>
<div class="line"><span class="keyword">from</span> pinocchio <span class="keyword">import</span> SE3</div>
<div class="line">nu = log(SE3.Random())</div>
<div class="line">nu_vec = nu.vector</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md168"></a>
Question 6</h3>
<p>Solve for the configuration that minimizes the norm of the logarithm of the difference between the end effector placement and the desired placement.</p>
<p>Optionally, try other metrics, like the log metric of \(R^3 \times SO(3)\), or the Froebenius norm of the homogeneous matrix.</p>
<h1><a class="anchor" id="autotoc_md169"></a>
2.4) Working with a mobile robot (optionnal)</h1>
<p>Until now, the tutorial only worked with a simple manipulator robot, i.e. whose configuration space is a real vector space. Consider now the humanoid robot, whose first joint is a free joint: it has 6 degrees of freedom (3 rotations, 3 translations) but its configuration vector is dimension 7. You can check it with <code>robot.model.nq</code>, that stores the dimension of the configuration, and <code>robot.model.nv</code>, that stores the dimension of the configuration velocity, i.e. the number of degrees of freedom. For the humanoid, <code>nq = nv + 1</code>.</p>
<p>Indeed, the configuration coefficients 3 to 7 are indeed representing a quaternion. The additional constraint is that these 4 coefficients must be normalize.</p>
<h3><a class="anchor" id="autotoc_md170"></a>
Question 7</h3>
<p>Display a configuration of the robot for which the norm of the quaternion is bigger than one (e.g. 2.0). What happens?</p>
<p>During the search, the solver must respect this constraint. A solution is to make this constraint explicit in the numerical program. However, we will start by an easier quick-and-dirty trick. With quaternions, the trick is simply to normalize any invalid quaternions. In the cost function, first normalize the quaternion before computing the cost due to the end-effector placement. An additional term should also be added to the cost function to avoid excessive drift of the quaternion norm, in particular with the norm going to 0.</p>
<h3><a class="anchor" id="autotoc_md171"></a>
Question 8</h3>
<p>Use <code>fmin_bfgs</code> to compute a configuration respecting a given placement with the humanoid model, by normalizing the quaternion at each step.</p>
<h3><a class="anchor" id="autotoc_md172"></a>
Question 9 (harder)</h3>
<p>Do the same with the solver C-LSQ <code>fmin_slsqp</code>, with the explicit constraint that the norm of the quaternion must be 1.</p>
<h1><a class="anchor" id="autotoc_md173"></a>
2.5) Configuration of a parallel robot</h1>
<p>A parallel robot is composed of several kinematic chains (called the robot legs) that are all attached to the same end effector. This imposes strict constraints in the configuration space of the robot: a configuration is valide iff all the legs meets the same end-effector placement. We consider here only the geometry aspect of parallel robots (additionnally, some joints are not actuated, which causes additional problems).</p>
<p>The kinematic structure of a paralel robot indeed induces loops in the joint connection graph. In Pinocchio, we can only represents (one of) the underlying kinematic tree. The loop constraints have to be handled separately. An example that loads 4 manipulator arms is <a href="ur5x4_8py_source.html">available here</a>. Each leg i (for i=0,1,2,3) of the robot is loaded in the list <code>robots[i]</code>. The loop constraints are that the relative placement of every leg end-effector must stay the same that in the initial configuration given as example in the above file.</p>
<h3><a class="anchor" id="autotoc_md174"></a>
Question 10</h3>
<p>Consider now that the orientation of the tool plate is given by the quaternion <code>Quaternion(0.7, 0.2, 0.2, 0.6)</code>, with the translation that you like. Find using the above optimization routines the configuration of each robot leg so that the loop constraints are all met. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacescipy_1_1optimize_html"><div class="ttname"><a href="namespacescipy_1_1optimize.html">optimize</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
